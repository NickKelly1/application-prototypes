"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @description
 * Is the handler to be fired every time?
 *
 * @param handler
 */
function isOn(handler) {
    return handler.type === 0;
}
/**
 * @description
 * Is the handler to be fired only once?
 *
 * @param handler
 */
function isOnce(handler) {
    return !isOn(handler);
}
class TypedEventDestroyedAccessError extends Error {
}
/**
 * @description
 * Typed, custom event emitter
 */
class TypedEvent {
    constructor() {
        this.handlers = [];
        this._isDestroyed = false;
        this.isDestroyed = () => this._isDestroyed;
        /**
         * Throw error if the wrapped function is invoked when this class is already destroyed
         *
         * @param fn
         */
        this.onlyIfNotDestroyed = (fn) => {
            const isDestroyedFn = this.isDestroyed;
            return function applyIfNotDestroyed(...args) {
                if (isDestroyedFn())
                    throw new TypedEventDestroyedAccessError();
                return fn(...args);
            };
            // return function applyIfNotDestroyed(this: TypedEvent<T>, ...args: Parameters<F>): ReturnType<F> {
            //   if (this.isDestroyed()) throw new TypedEventDestroyedAccessError();
            //   return fn(...args);
            // }
        };
        /**
         * @description
         * Return a function that unsubscribes the listener from the bound array
         */
        this.getOff = (removeHandlers) => () => {
            this.handlers = this
                .handlers
                .filter(h => removeHandlers instanceof Array
                ? !removeHandlers.includes(h)
                : h !== removeHandlers);
        };
        /**
         * @description
         * Listen to event emissions
         */
        this.on = this.onlyIfNotDestroyed((listener) => {
            const onHandler = { type: 0, func: listener };
            this.handlers.push(onHandler);
            return { dispose: () => this.getOff(onHandler) };
        });
        /**
         * @description
         * Listen to only a single event emission
         */
        this.once = this.onlyIfNotDestroyed((listener) => {
            const onceHandler = { type: 1, func: listener };
            this.handlers.push(onceHandler);
            return { dispose: () => this.getOff(onceHandler) };
        });
        /**
         * @description
         * Emit an event
         * Fire listeners
         */
        this.emit = this.onlyIfNotDestroyed((event) => {
            const oldHandlers = this.handlers.slice();
            this.handlers = this.handlers.filter(h => h.type === 0);
            oldHandlers.forEach(({ func }) => func(event));
        });
        /**
         * @description
         * Pipe events through to another emitter
         */
        this.pipe = this.onlyIfNotDestroyed((te) => {
            return this.on((e) => te.emit(e));
        });
        /**
         * @description
         * Push an array of handlers onto the handler stack
         */
        this.bindHandlers = this.onlyIfNotDestroyed((handlers) => handlers
            .map(handler => isOnce(handler)
            ? this.once(handler.func)
            : this.on(handler.func)));
        /**
         * @description
         * Remove all event handlers
         */
        this.destroy = this.onlyIfNotDestroyed(() => {
            this.handlers = [];
            this._isDestroyed = true;
        });
    }
}
exports.TypedEvent = TypedEvent;

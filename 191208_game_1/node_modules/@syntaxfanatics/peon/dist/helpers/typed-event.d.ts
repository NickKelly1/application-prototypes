interface Listener<T> {
    (event: T): any;
}
interface Disposable {
    dispose: Function;
}
export declare type OnHandler<T> = {
    type: 0;
    func: Listener<T>;
};
export declare type OnceHandler<T> = {
    type: 1;
    func: Listener<T>;
};
export declare type Handler<T> = OnHandler<T> | OnceHandler<T>;
/**
 * @description
 * Typed, custom event emitter
 */
export declare class TypedEvent<T> {
    handlers: Handler<T>[];
    private _isDestroyed;
    isDestroyed: () => boolean;
    /**
     * Throw error if the wrapped function is invoked when this class is already destroyed
     *
     * @param fn
     */
    private onlyIfNotDestroyed;
    /**
     * @description
     * Return a function that unsubscribes the listener from the bound array
     */
    private getOff;
    /**
     * @description
     * Listen to event emissions
     */
    on: (listener: Listener<T>) => Disposable;
    /**
     * @description
     * Listen to only a single event emission
     */
    once: (listener: Listener<T>) => Disposable;
    /**
     * @description
     * Emit an event
     * Fire listeners
     */
    emit: (event: T) => void;
    /**
     * @description
     * Pipe events through to another emitter
     */
    pipe: (te: TypedEvent<T>) => Disposable;
    /**
     * @description
     * Push an array of handlers onto the handler stack
     */
    bindHandlers: (handlers: Handler<T>[]) => Disposable[];
    /**
     * @description
     * Remove all event handlers
     */
    destroy: () => void;
}
export {};
